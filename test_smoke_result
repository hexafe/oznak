============================= test session starts ==============================
platform linux -- Python 3.14.0, pytest-9.0.1, pluggy-1.6.0 -- /home/hexaf/.local/share/mise/installs/python/3.14.0/bin/python
cachedir: .pytest_cache
rootdir: /home/hexaf/Projects/oznak
plugins: anyio-4.12.0
collecting ... collected 4 items

tests/test_smoke.py::test_import_core_modules PASSED                     [ 25%]
tests/test_smoke.py::test_instantiate_core_classes PASSED                [ 50%]
tests/test_smoke.py::test_multi_database_fetcher_integration FAILED      [ 75%]
tests/test_smoke.py::test_cli_app_loads PASSED                           [100%]

=================================== FAILURES ===================================
___________________ test_multi_database_fetcher_integration ____________________

mock_read_sql = <MagicMock name='read_sql' id='140054669892912'>
mock_db_manager_class = <MagicMock name='DBManager' id='140054669895600'>

    @patch("src.services.multi_database_fetcher.DBManager")
    @patch("src.query.fetcher.pd.read_sql")
    def test_multi_database_fetcher_integration(mock_read_sql, mock_db_manager_class):
        # Arrange
        mock_db_manager_instance = Mock()
        mock_engine = Mock()
        mock_db_manager_instance.get_engine.return_value = mock_engine
        mock_db_manager_instance.cfg = {
            "database1": {"table": "test_table"}
        }
        mock_db_manager_class.return_value = mock_db_manager_instance
    
        # Mock the return value of pd.read_sql (which is called by fetch_data)
        mock_read_sql.return_value = pd.DataFrame({"col1": [1], "col2": ["test"]})
    
        # Instantiate the fetcher and inject the mocked DB manager
        from src.services.multi_database_fetcher import MultiDatabaseFetcher
        fetcher = MultiDatabaseFetcher()
        fetcher.db = mock_db_manager_instance
    
        # Act
        filters = ["test_col = test_val"]
        result_df = fetcher.fetch(["database1"], filters, limit=1, date_column="Date")
    
        # Assert
>       mock_db_manager_instance.get_engine.assert_called_once_with("database1")

tests/test_smoke.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='DBManager().get_engine' id='140054669895264'>
args = ('database1',), kwargs = {}
msg = "Expected 'get_engine' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_engine' to be called once. Called 0 times.

../../.local/share/mise/installs/python/3.14.0/lib/python3.14/unittest/mock.py:996: AssertionError
----------------------------- Captured stdout call -----------------------------
Processing database 1/1: database1
   └── Query: SELECT * FROM `test_table` WHERE `test_col` = :par...
Executing query on database...
Fetched 1 records from query: SELECT * FROM `test_table` WHERE `test_col` = :par...
Combining data from 1 databases...
Combined 1 records from 1 databases
=========================== short test summary info ============================
FAILED tests/test_smoke.py::test_multi_database_fetcher_integration - Asserti...
========================= 1 failed, 3 passed in 0.65s ==========================
